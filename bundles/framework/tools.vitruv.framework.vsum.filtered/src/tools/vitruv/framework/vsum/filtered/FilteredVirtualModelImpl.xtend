package tools.vitruv.framework.vsum.filtered

import accesscontrol.OperationAccessRightEvaluator
import accesscontrol.OperationAccessRightUtil
import accesscontrolsystem.RuleDatabase
import java.util.Collection
import java.util.List
import java.util.Objects
import java.util.Optional
import java.util.Set
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl
import org.eclipse.xtend.lib.annotations.Delegate
import tools.vitruv.framework.change.description.PropagatedChange
import tools.vitruv.framework.change.description.VitruviusChange
import tools.vitruv.framework.change.echange.EChange
import tools.vitruv.framework.change.echange.eobject.DeleteEObject
import tools.vitruv.framework.change.echange.feature.FeatureEChange
import tools.vitruv.framework.change.echange.id.IdResolver
import tools.vitruv.framework.change.echange.root.InsertRootEObject
import tools.vitruv.framework.views.ViewSelector
import tools.vitruv.framework.views.ViewSource
import tools.vitruv.framework.views.ViewType
import tools.vitruv.framework.vsum.VirtualModel
import tools.vitruv.framework.vsum.filtered.correspondence.Correspondences
import tools.vitruv.framework.vsum.filtered.correspondence.ModificationExtractor
import tools.vitruv.framework.vsum.internal.InternalVirtualModel
import accesscontrol.ResourceSetFilter

/**
 * Class decorating an {@link InternalVirtualModel} with a filter mechanism. 
 * Through this filter mechanism, the underlying virtual model only partly 
 * reveals the underlying models based on the given {@link RuleDatabase} 
 * through the {@link ViewSource#getViewSourceModels() getViewSourceModels} method. The revealed {@link Resource}s 
 * are filtered copies from the underlying {@link Resource}s.
 * Due to it being modifications on copies, modifies the changes propagated to it with {@link #propagateChange(VitruviusChange change)}
 * to use indices and objects from the encapsulated {@link InternalVirtualModel}s {@link Resource}s. 
 * Moreover modifies the {@link RuleDatabase} with changes generated by {@link #propagateChange(VitruviusChange change)}.
 */
class FilteredVirtualModelImpl implements InternalVirtualModel {

	/**
	 * Model containing the raw unfiltered data. Delegating calls which do not modify the content or allow access to this internal model.
	 */
	@Delegate val InternalVirtualModel internalModel

	/**
	 * The Utility to filter the resources.
	 */
	val ResourceSetFilter filteredResourceSet

	/**
	 * The filtered resources encapsulated in a ResourceSet, may be empty.
	 */
	ResourceSet filteredResource

	/**
	 * Indicates whether or not the resources have been changed and thus the {@link #filteredResource} is not valid anymore and has to be recomputed.
	 */
	var boolean changed

	/**
	 * @param ruleDatabase the {@link RuleDatabase} containing filter rules, may be null (in that case a new empty one is used, located in the vsum folder)
	 * @param roleInformation contains information to identify the available roles (as of now 01.03.2022, the index in the list is used,
	 * 			will be changed to some kind of access token or similar once the whole package is updated with a security point of view)
	 */
	new(InternalVirtualModel internalModel, RuleDatabase ruleDatabase, Collection<Integer> roleInformation,
		OperationAccessRightEvaluator evaluator) {
		Objects.requireNonNull(evaluator)
		Objects.requireNonNull(internalModel)
		this.internalModel = internalModel
		changed = true
		filteredResourceSet = ResourceSetFilter.create(ruleDatabase, roleInformation, evaluator)
		filteredResource = new ResourceSetImpl()
	}

	/**
	 * @see VirtualModel#propagateChange(VitruviusChange change)
	 */
	override propagateChange(VitruviusChange change) {
		var idCrossResolver = IdCrossResolver.create(getUnfilteredResourceSetOrEmptyNew, filteredResource,
			filteredResourceSet)
		// we only have to change indices if there was a filtering involved
		if (!filteredResource.resources.isEmpty) {
			modifyChangesFromFilteredToUnfilteredResources(change, idCrossResolver)
		}
		// if a filtering operation is involved, add the correspondence relation with the idCrossResolver so
		// they can be resolved by the propagation algorithm
		val changes = filteredResource.resources.isEmpty ? internalModel.propagateChange(change) : internalModel.
				propagateChange(change, Optional.of(idCrossResolver))
		updateAccessControlSystem(changes, idCrossResolver);
		return changes
	}

	private def boolean updateAccessControlSystem(List<PropagatedChange> changes,
		IdResolver resolver) {
		modifyAccessControlSystem(changes.map[it.originalChange].flatMap[it.EChanges], resolver)
		modifyAccessControlSystem(changes.map[it.consequentialChanges].flatMap[it.EChanges], resolver)
		changed = true
	}

	private def ResourceSet getUnfilteredResourceSetOrEmptyNew() {
		return internalModel.viewSourceModels.empty
			? new ResourceSetImpl()
			: internalModel.viewSourceModels.iterator.next.resourceSet
	}

	override getViewSourceModels() {
		if (changed) {
			filteredResource = filteredResourceSet.filter(getUnfilteredResourceSetOrEmptyNew, OperationAccessRightUtil.neededRightsViewing)
			changed = false
		}
		return filteredResource.resources
	}

	override <S extends ViewSelector> createSelector(ViewType<S> viewType) {
		viewType.createSelector(this)
	}

	package def Collection<Resource> getUnfilteredViewSourceModels() {
		return this.internalModel.viewSourceModels
	}

	package def ResourceSetFilter getFilteredResourceSet() {
		return this.filteredResourceSet
	}

	def boolean canModify(Collection<EObject> eObjects) {
		this.filteredResourceSet.canModify(eObjects, OperationAccessRightUtil.neededRightsModifying)
	}

	private def boolean modifyAccessControlSystem(Iterable<EChange> changes, IdResolver resolver) {
		// becaus the changes have been applied at this point we have to update the correspondence table in the filteredResourceSet by executing the filtering
		viewSourceModels
		var success = true
		for (change : changes) {
			if (change instanceof InsertRootEObject) {
				success = success &&
					filteredResourceSet.addAccessRule(resolver.getEObject(resolver.getAndUpdateId(change.newValue)), null,  List.of(OperationAccessRightUtil.allowRead, OperationAccessRightUtil.allowWrite))
			// access restrictions on non EObject types are not supported at the moment!
			} else if (change instanceof DeleteEObject) {
				success = success &&
					filteredResourceSet.removeAccessRules(
						resolver.getEObject(resolver.getAndUpdateId(change.affectedEObject)))
			}
		}
		return success
	}

	private def void modifyChangesFromFilteredToUnfilteredResources(VitruviusChange change,
		IdCrossResolver idCrossResolver) {
		val correspondences = new Correspondences(change, idCrossResolver)
		checkIfModifiedObjectsCanBeModified(correspondences, idCrossResolver)
		val modifications = new ModificationExtractor(correspondences, idCrossResolver).extract()
		modifications.filter[it.containsChange].forEach[it.apply]
	}

	private def void checkIfModifiedObjectsCanBeModified(Correspondences correspondences, IdCrossResolver resolver) {
		for (FeatureEChange<EObject, EReference> echange : correspondences.modifiedObjects) {
			if (resolver.hasEObject(echange.affectedEObjectID)) {
				if (!filteredResourceSet.canModify(Set.of(resolver.getEObject(echange.affectedEObjectID)), OperationAccessRightUtil.neededRightsModifying)) {
					throw new IllegalStateException(
						"Tried to modify element " + resolver.getEObject(echange.affectedEObjectID) + " with id " +
							echange.affectedEObjectID + " without access and with change " + echange + " in resource " +
							echange.affectedEObject.eResource)
				}
			}
		}
	}
}
