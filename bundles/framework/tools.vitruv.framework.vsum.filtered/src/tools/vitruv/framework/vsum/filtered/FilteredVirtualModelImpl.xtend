package tools.vitruv.framework.vsum.filtered

import java.util.Collection
import java.util.List
import java.util.Objects
import java.util.Optional
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl
import org.eclipse.xtend.lib.annotations.Delegate
import tools.vitruv.framework.change.description.PropagatedChange
import tools.vitruv.framework.change.description.VitruviusChange
import tools.vitruv.framework.change.echange.EChange
import tools.vitruv.framework.change.echange.eobject.DeleteEObject
import tools.vitruv.framework.change.echange.id.IdResolver
import tools.vitruv.framework.change.echange.root.InsertRootEObject
import tools.vitruv.framework.views.ChangeableViewSource
import tools.vitruv.framework.views.ViewSelector
import tools.vitruv.framework.views.ViewSource
import tools.vitruv.framework.views.ViewType
import tools.vitruv.framework.vsum.VirtualModel
import tools.vitruv.framework.vsum.accesscontrolsystem.RuleDatabase
import tools.vitruv.framework.vsum.accesscontrolsystem.accesscontrol.OperationAccessRightEvaluator
import tools.vitruv.framework.vsum.accesscontrolsystem.accesscontrol.OperationAccessRightUtil
import tools.vitruv.framework.vsum.accesscontrolsystem.accesscontrol.ResourceFilter
import tools.vitruv.framework.vsum.filtered.correspondence.ModificationExtractor
import tools.vitruv.framework.vsum.internal.InternalVirtualModel

/**
 * Class decorating an {@link InternalVirtualModel} with a filter mechanism. 
 * Through this filter mechanism, the underlying virtual model only partly 
 * reveals the underlying models based on the given {@link RuleDatabase} 
 * through the {@link ViewSource#getViewSourceModels() getViewSourceModels} method. The revealed {@link Resource}s 
 * are filtered copies from the underlying {@link Resource}s.
 * Due to it being modifications on copies, modifies the changes propagated to it with {@link #propagateChange(VitruviusChange change)}
 * to use indices and objects from the encapsulated {@link InternalVirtualModel}s {@link Resource}s. 
 * Moreover modifies the {@link RuleDatabase} with changes generated by {@link #propagateChange(VitruviusChange change)}.
 */
class FilteredVirtualModelImpl implements VirtualModel, ChangeableViewSource {

	/**
	 * Model containing the raw unfiltered data. Delegating calls which do not modify the content or allow access to this internal model.
	 */
	@Delegate val InternalVirtualModel internalModel
	/**
	 * The Utility to filter the resources.
	 */
	var ResourceFilter resourceSetFilter

	val RuleDatabase ruleDatabase
	
	val Collection<Integer> roleInformation
	val OperationAccessRightEvaluator evaluator

	/**
	 * @param ruleDatabase the {@link RuleDatabase} containing filter rules, may be null (in that case a new empty one is used, located in the vsum folder)
	 * @param roleInformation contains information to identify the available roles (as of now 01.03.2022, the index in the list is used,
	 * 			will be changed to some kind of access token or similar once the whole package is updated with a security point of view)
	 */
	new(InternalVirtualModel internalModel, RuleDatabase ruleDatabase, Collection<Integer> roleInformation,
		OperationAccessRightEvaluator evaluator) {
		Objects.requireNonNull(evaluator)
		Objects.requireNonNull(internalModel)
		this.internalModel = internalModel
		this.roleInformation = roleInformation
		this.evaluator = evaluator
		resourceSetFilter = ResourceFilter.create(ruleDatabase, roleInformation, evaluator, internalModel.viewSourceModels,
				OperationAccessRightUtil.neededRightsViewing)
		this.ruleDatabase = resourceSetFilter.ruleDatabase
	}
	

	/**
	 * @see VirtualModel#propagateChange(VitruviusChange change)
	 */
	override propagateChange(VitruviusChange change) {
		var idCrossResolver = IdCrossResolver.create(getUnfilteredResourceSetOrEmptyNew, getFilteredResourceSetOrEmptyNew,
			resourceSetFilter)
		// we only have to change indices if there was a filtering involved
		if (!getFilteredResourceSetOrEmptyNew.resources.isEmpty) {
			modifyChangesFromFilteredToUnfilteredResources(change, idCrossResolver)
		}
		// if a filtering operation is involved, add the correspondence relation with the idCrossResolver so
		// they can be resolved by the propagation algorithm
		val changes = getFilteredResourceSetOrEmptyNew.resources.isEmpty
				? internalModel.propagateChange(change)
				: internalModel.propagateChange(change, Optional.of(idCrossResolver))
		updateAccessControlSystem(changes, idCrossResolver);
		resourceSetFilter = ResourceFilter.create(ruleDatabase, roleInformation, evaluator, internalModel.viewSourceModels,
				OperationAccessRightUtil.neededRightsViewing)
		return changes
	}

	private def boolean updateAccessControlSystem(List<PropagatedChange> changes, IdResolver resolver) {
		modifyAccessControlSystem(changes.map[it.originalChange].flatMap[it.EChanges], resolver)
		modifyAccessControlSystem(changes.map[it.consequentialChanges].flatMap[it.EChanges], resolver)
	}

	private def ResourceSet getUnfilteredResourceSetOrEmptyNew() {
		return internalModel.viewSourceModels.empty ? new ResourceSetImpl() : internalModel.viewSourceModels.iterator.
			next.resourceSet
	}
	
	private def ResourceSet getFilteredResourceSetOrEmptyNew() {
		return resourceSetFilter.filteredResources.empty ? new ResourceSetImpl() : resourceSetFilter.filteredResources.get(0).resourceSet
	}

	override getViewSourceModels() {
		return resourceSetFilter.filteredResources
	}

	override <S extends ViewSelector> createSelector(ViewType<S> viewType) {
		viewType.createSelector(this)
	}

	package def Collection<Resource> getUnfilteredViewSourceModels() {
		return this.internalModel.viewSourceModels
	}

	package def ResourceFilter getResourceSetFilter() {
		return this.resourceSetFilter
	}

	def boolean canModify(Collection<EObject> eObjects) {
		this.resourceSetFilter.hasAccessRights(eObjects, OperationAccessRightUtil.neededRightsModifying)
	}

	private def boolean modifyAccessControlSystem(Iterable<EChange> changes, IdResolver resolver) {
		// becaus the changes have been applied at this point we have to update the correspondence table in the filteredResourceSet by executing the filtering
		var success = true
		for (change : changes) {
			if (change instanceof InsertRootEObject) {
				success = success &&
					resourceSetFilter.addAccessRule(change.newValue,
						null, List.of(OperationAccessRightUtil.allowRead, OperationAccessRightUtil.allowWrite))
			// access restrictions on non EObject types are not supported at the moment!
			} else if (change instanceof DeleteEObject) {
				success = success &&
					resourceSetFilter.removeAccessRules(change.affectedEObject)
			}
		}
		return success
	}

	private def void modifyChangesFromFilteredToUnfilteredResources(VitruviusChange change,
		IdCrossResolver idCrossResolver) {
		val modifications = new ModificationExtractor(change, idCrossResolver).extract(idCrossResolver, resourceSetFilter)
		modifications.filter[it.containsChange].forEach[it.apply]
	}
}
